import os
import pandas as pd
import skimage
from torch.utils.data import Dataset
from pylabel import importer
from torchvision import transforms
from thirdparty.openISP.pipeline import Pipeline
import numpy as np
from dataset.utils import name_2_ficosa_id


class CustomVOC(Dataset):
    """ Dataset loader using VOC annotations format"""
    def __init__(self, annotations_folder, classes=["car"], transform=None, target_transform=None):
        """
        :param annotations_folder: Path to the images and annotations folder.
        :param classes: List of classes that we want to filter.
                    Default value ["car"].
        :param transform: Image transformations we want to attach to the dataloader.
                        Default value None.
        :param target_transform: Bounding boxes transformations we want to attach to the dataloader.
                            Default value None.
        """

        self.annotations_folder = annotations_folder
        self.classes = classes
        self.transform = transform
        self.target_transform = target_transform

        # Load and preprocess the VOC dataset using pylabel.importer object
        dataset = importer.ImportVOC(path=annotations_folder, path_to_images=annotations_folder)
        # Filter the classes of our interest
        filtered_df = dataset.df.query('cat_name in @classes')
        # Refactor the dataset to a dict with the image path of each image and their corresponding bounding boxes
        self.data = self._process_data(filtered_df)

    def update_transform(self, transform=None):
        """
        :param transform: Image transformations we want to attach to the dataloader.
                        Default value None.
        """
        self.transform = transform

    def _process_data(self, df):
        """
        :param df: Pandas table generated by pylabel.importer object.
        :return: Dictionary with the following struct for each image.
                dataset_dict[string(image_name)] = {'img_path': string(image_path), 'bboxes': list(bboxes)}
        """
        dataset_dict = {}
        img_id_list = df['img_id'].unique().tolist()

        for img_id in img_id_list:
            rows = df[df['img_id'] == img_id]
            img_name = rows['img_filename'].values[0]
            img_path = os.path.join(rows['img_folder'].values[0], img_name)
            bboxes = []
            for _, row in rows.iterrows():
                top_left_x = int(row['ann_bbox_xmin'])
                top_left_y = int(row['ann_bbox_ymin'])
                bottom_right_x = int(row['ann_bbox_xmax'])
                bottom_right_y = int(row['ann_bbox_ymax'])
                cls = row['cat_name']
                bboxes.append([top_left_x, top_left_y, bottom_right_x, bottom_right_y, name_2_ficosa_id(cls)])

            dataset_dict[img_name.split('.')[0]] = {'img_path': img_path, 'bboxes': bboxes}

        return dataset_dict

    def __len__(self):
        """
        :return: Quantity of images in the dataset.
        """
        return len(self.data)

    def __getitem__(self, idx):
        """
        :param idx: Index of the image we want to retrieve
        :return: A tuple composed by the image and its corresponding bounding boxes.
        """
        img_info = self.data[list(self.data.keys())[idx]]
        img_path = img_info['img_path']
        bboxes = img_info['bboxes']

        # Load image
        img = skimage.io.imread(img_path).astype(np.uint8)

        # Apply transformations (if any)
        if self.transform is not None:
            img = self.transform(img)
        if self.target_transform is not None:
            bboxes = self.target_transform(bboxes)

        return img, bboxes


class ImageProcessingTransform:
    """ Custom dataloader transformation that passes the images by the ISP pipeline """
    def __init__(self, isp_conf, verbose=False):
        """
        :param isp_conf: Configuration file for the fast openISP module.
        :param verbose: Boolean that enables/disables printing on terminal the computation time of each ISP module.
                        Default value False.
        """
        self.verbose = verbose
        self.pipeline = Pipeline(isp_conf)

    def __call__(self, img):
        """
        :param img: RAW image we want to process.
        :return: Processed image.
        """
        bayer = img.astype(np.uint8)
        data, _ = self.pipeline.execute(bayer, verbose=self.verbose)
        processed_img = data['output']

        return processed_img
