#!/usr/bin/env python3

# Standard library imports
import os
import json
import subprocess
from time import sleep

# External package imports
import cv2
import numpy as np
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge

# Local package imports
from pylabel import importer


class DataLoaderNode(Node):
    """Node for loading datasets using VOC annotations format and publishing images."""

    def __init__(self):
        super().__init__("data_loader")

        # Parameters
        self.declare_parameter("annotations_folder_path", "/home/rachid/raw_dataset/test/")
        self.declare_parameter("classes_list", ["car"])
        self.declare_parameter("publish_frequency", 1.0)
        self.declare_parameter("isp_json_path", "./isp_configuration.json")

        # Initialize parameters
        self.annotations_folder_path = self.get_parameter("annotations_folder_path").value
        self._classes_list = self.get_parameter("classes_list").value
        self._publish_frequency = self.get_parameter("publish_frequency").value
        self._isp_json_path = self.get_parameter("isp_json_path").value

        # Initialize bridge for converting ROS Image messages to OpenCV format
        self.bridge = CvBridge()

        # Start ISP node
        self.isp_node = self.start_isp_node()

        # Load dataset
        self.dataset_dict = self.load_dataset()

        # Publishers and subscribers
        self.raw_image_publisher_ = self.create_publisher(Image, "raw_image", 10)
        self.rgb_image_subscriber_ = self.create_subscription(
            Image, "rgb_image", self.callback_rgb_image, 10
        )

        # Log initialization
        self.get_logger().info("DataLoaderNode initialized.")

        # Publish images
        self.publish_images()

        # Stop ISP node
        self.stop_ros2_node(self.isp_node)

    def load_dataset(self):
        """
        Load dataset and preprocess it.
        Refactor the dataset to a dict with the image path of each image and corresponding bounding
        boxes. Example: 
        {'000': {'img_path': '/home/rachid/raw_dataset/test/000.raw', 
                'bboxes': [[top_left_x,
                            top_left_y,
                            bottom_right_x,
                            bottom_right_y,
                            class_id]]}}
        """
        dataset_dataframe = importer.ImportVOC(path=self.annotations_folder_path)
        return self.convert_dataframe_to_dict(dataset_dataframe)

    def convert_dataframe_to_dict(self, dataframe):
        """
        Convert dataset dataframe to a dictionary.

        Args:
            dataframe: Pandas DataFrame generated by pylabel.importer object.

        Returns:
            Dictionary with image names as keys and corresponding paths and bounding boxes as values.
        """
        dataset_dict = {}

        # Filter the classes of interest
        dataframe_filtered_by_class = dataframe.df.query("cat_name in @self._classes_list")

        img_id_list = dataframe_filtered_by_class["img_id"].unique().tolist()

        for img_id in img_id_list:
            rows = dataframe_filtered_by_class[dataframe_filtered_by_class["img_id"] == img_id]
            img_name = rows["img_filename"].values[0]
            img_path = os.path.join(self.annotations_folder_path, img_name)
            bboxes = []
            for _, row in rows.iterrows():
                top_left_x = int(row["ann_bbox_xmin"])
                top_left_y = int(row["ann_bbox_ymin"])
                bottom_right_x = int(row["ann_bbox_xmax"])
                bottom_right_y = int(row["ann_bbox_ymax"])
                cls = row["cat_name"]
                bboxes.append(
                    [
                        top_left_x,
                        top_left_y,
                        bottom_right_x,
                        bottom_right_y,
                        self._convert_class_name_2_ficosa_id(cls),
                    ]
                )

            dataset_dict[img_name.split(".")[0]] = {
                "img_path": img_path,
                "bboxes": bboxes,
            }

        return dataset_dict

    def callback_rgb_image(self, msg):
        """Callback function for processing RGB images."""
        self.get_logger().info("Received an image.")
        self.get_logger().info("Width: " + str(msg.width))
        self.get_logger().info("Height: " + str(msg.height))

        # Convert ROS Image message to OpenCV format
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except CvBridgeError as e:
            print("Error converting ROS Image to OpenCV format: %s" % str(e))
            return

        # Display the image
        image_resized = self.resize_with_aspect_ratio(cv_image, width=1280)  # Resize by width
        cv2.imshow("Received Image", image_resized)
        cv2.waitKey()  # Wait indefinitely until a key is pressed
        cv2.destroyAllWindows()  # Close all OpenCV windows when done

    def resize_with_aspect_ratio(self, image, width=None, height=None, inter=cv2.INTER_AREA):
        """Resize an image while maintaining aspect ratio."""
        dim = None
        (h, w) = image.shape[:2]

        if width is None and height is None:
            return image
        if width is None:
            r = height / float(h)
            dim = (int(w * r), height)
        else:
            r = width / float(w)
            dim = (width, int(h * r))

        return cv2.resize(image, dim, interpolation=inter)

    def publish_images(self):
        """Publish images from the dataset."""
        for image in self.dataset_dict:
            image_path = self.dataset_dict[image]["img_path"]
            self.publish_image(image_path)
            break

    def publish_image(self, image_path):
        """Publish an image."""
        with open(image_path, "rb") as f:
            raw_data = f.read()

        width = 4656
        height = 3496
        msg = Image()
        msg.header.frame_id = "OnePlus_A3003"
        msg.height = height
        msg.width = width
        msg.encoding = "mono16"
        msg.step = width * 2
        msg.data = raw_data

        self.raw_image_publisher_.publish(msg)
        self.get_logger().info("Image published.")

    def create_json_file(self, file_path):
        """Create a JSON file if it doesn't exist."""
        if not os.path.exists(file_path):
            with open(file_path, "w") as file:
                json.dump({}, file)

    def start_isp_node(self):
        """Start the ISP node."""
        command = "ros2 run hdr_isp hdr_isp " + self._isp_json_path
        ros2_process = subprocess.Popen(["gnome-terminal", "--", "bash", "-c", command])
        return ros2_process

    def stop_ros2_node(self, ros2_process):
        """Stop the ROS2 node."""
        # ros2_process.kill()
        # ros2_process.terminate()
        self.get_logger().info("ISP node killed.")
    
    def _convert_class_name_2_ficosa_id(self, class_name):
        name_to_id = {
            "car": 0,
            "truck": 1,
            "bicycle": 2,
            "person": 3,
            "motorbike": 4,
            "bus": 5,
            "traffic_sign": 6,
            "traffic_light": 7,
        }
        return name_to_id[class_name]


def main(args=None):
    """Main function."""
    rclpy.init(args=args)
    node = DataLoaderNode()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == "__main__":
    main()
